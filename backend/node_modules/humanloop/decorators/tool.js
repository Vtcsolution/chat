"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toolUtilityFactory = toolUtilityFactory;
const context_1 = require("../context");
const otel_1 = require("../otel");
const constants_1 = require("../otel/constants");
/**
 * Higher-order function for wrapping a function with OpenTelemetry instrumentation.
 * It inspects the argument signature of the wrapped function to build a JSON schema.
 *
 * @param func - The function to wrap
 * @param opentelemetryTracer - The OpenTelemetry tracer instance
 * @param path - Optional span path
 * @param version - Additional metadata for the function
 * @returns Wrapped function with OpenTelemetry instrumentation
 */
function toolUtilityFactory(opentelemetryTracer, callable, version, path) {
    const fileType = "tool";
    const wrappedFunction = (inputs) => __awaiter(this, void 0, void 0, function* () {
        const evaluationContext = (0, context_1.getEvaluationContext)();
        if (evaluationContext && evaluationContext.path === path) {
            throw new Error("Tools cannot be evaluated with the `evaluations.run()` utility.");
        }
        validateArgumentsAgainstSchema(version, inputs);
        // @ts-ignore
        return opentelemetryTracer.startActiveSpan(constants_1.HUMANLOOP_TOOL_SPAN_NAME, (span) => __awaiter(this, void 0, void 0, function* () {
            // Add span attributes
            (0, otel_1.writeToOpenTelemetrySpan)(span, Object.assign({}, version), constants_1.HUMANLOOP_FILE_KEY);
            span = span.setAttribute(constants_1.HUMANLOOP_FILE_TYPE_KEY, fileType);
            span = span.setAttribute(constants_1.HUMANLOOP_PATH_KEY, path);
            let logInputs = Object.assign({}, inputs);
            let logError;
            let logOutput;
            let funcOutput;
            try {
                funcOutput = yield callable(inputs);
                logOutput = (0, otel_1.jsonifyIfNotString)(callable, funcOutput);
                logError = undefined;
            }
            catch (err) {
                console.error(`Error calling ${callable.name}:`, err);
                funcOutput = undefined;
                logOutput = undefined;
                logError = err.message || String(err);
            }
            const toolLog = {
                inputs: logInputs,
                output: logOutput,
                error: logError,
                trace_parent_id: (0, context_1.getTraceId)(),
            };
            (0, otel_1.writeToOpenTelemetrySpan)(span, toolLog, constants_1.HUMANLOOP_LOG_KEY);
            span.end();
            return funcOutput;
        }));
    });
    // @ts-ignore Adding jsonSchema property to utility-wrapped function
    return Object.assign(wrappedFunction, {
        jsonSchema: version.function || {},
    });
}
function validateArgumentsAgainstSchema(toolKernel, inputs) {
    var _a, _b, _c, _d;
    const parameters = ((_b = (_a = toolKernel.function) === null || _a === void 0 ? void 0 : _a.parameters) === null || _b === void 0 ? void 0 : _b.properties) || {};
    if (!parameters || Object.keys(parameters).length === 0) {
        if (inputs === undefined) {
            return;
        }
        throw new Error(`Tool function ${(_c = toolKernel.function) === null || _c === void 0 ? void 0 : _c.name} received inputs when the JSON schema defines none`);
    }
    if (inputs === undefined) {
        if (Object.keys(parameters).length > 0 || !parameters) {
            throw new Error(`Tool function ${(_d = toolKernel.function) === null || _d === void 0 ? void 0 : _d.name} expected inputs but received none.`);
        }
    }
    Object.keys(inputs).forEach((inputKey) => {
        if (!parameters.hasOwnProperty(inputKey)) {
            throw new Error(`Inputs key '${inputKey}' does not match the JSON schema.`);
        }
    });
}
