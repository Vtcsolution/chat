"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.flowUtilityFactory = flowUtilityFactory;
const context_1 = require("../context");
const otel_1 = require("../otel");
const constants_1 = require("../otel/constants");
function flowUtilityFactory(client, opentelemetryTracer, callable, path, attributes) {
    const flowKernel = { attributes: attributes || {} };
    const fileType = "flow";
    const wrappedFunction = (inputs) => __awaiter(this, void 0, void 0, function* () {
        return context_1.HL_CONTEXT.with((0, context_1.setDecoratorContext)({
            path: path,
            type: fileType,
            version: flowKernel,
        }), () => __awaiter(this, void 0, void 0, function* () {
            return opentelemetryTracer.startActiveSpan(constants_1.HUMANLOOP_FLOW_SPAN_NAME, (span) => __awaiter(this, void 0, void 0, function* () {
                span.setAttribute(constants_1.HUMANLOOP_PATH_KEY, path);
                span.setAttribute(constants_1.HUMANLOOP_FILE_TYPE_KEY, fileType);
                const traceId = (0, context_1.getTraceId)();
                const logInputs = Object.assign({}, inputs);
                const logMessages = logInputs.messages;
                delete logInputs.messages;
                const initLogInputs = {
                    inputs: logInputs,
                    messages: logMessages,
                    traceParentId: traceId,
                };
                const flowLogResponse = 
                // @ts-ignore
                yield client.flows._log(Object.assign({ path, flow: flowKernel, logStatus: "incomplete" }, initLogInputs));
                return yield context_1.HL_CONTEXT.with((0, context_1.setTraceId)(flowLogResponse.id), () => __awaiter(this, void 0, void 0, function* () {
                    let logOutput;
                    let outputMessage;
                    let logError;
                    let funcOutput;
                    try {
                        funcOutput = yield callable(inputs);
                        if (
                        // @ts-ignore
                        funcOutput instanceof Object &&
                            "role" in funcOutput &&
                            "content" in funcOutput) {
                            outputMessage =
                                funcOutput;
                            logOutput = undefined;
                        }
                        else {
                            logOutput = (0, otel_1.jsonifyIfNotString)(callable, funcOutput);
                            outputMessage = undefined;
                        }
                        logError = undefined;
                    }
                    catch (err) {
                        console.error(`Error calling ${callable.name}:`, err);
                        logOutput = undefined;
                        outputMessage = undefined;
                        logError = err.message || String(err);
                        funcOutput = undefined;
                    }
                    const updatedFlowLog = {
                        log_status: "complete",
                        output: logOutput,
                        error: logError,
                        output_message: outputMessage,
                        id: flowLogResponse.id,
                    };
                    (0, otel_1.writeToOpenTelemetrySpan)(span, 
                    // @ts-ignore
                    updatedFlowLog, constants_1.HUMANLOOP_LOG_KEY);
                    span.end();
                    return funcOutput;
                }));
            }));
        }));
    });
    return Object.assign(wrappedFunction, {
        file: {
            path: path,
            type: fileType,
            version: flowKernel,
            callable: wrappedFunction,
        },
    });
}
