"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HumanloopSpanProcessor = void 0;
const context_1 = require("../context");
const constants_1 = require("./constants");
const helpers_1 = require("./helpers");
class HumanloopSpanProcessor {
    constructor(exporter) {
        this.spanExporter = exporter;
    }
    onStart(span, _) {
        if ((0, helpers_1.isLLMProviderCall)(span)) {
            const decoratorContext = (0, context_1.getDecoratorContext)();
            if (decoratorContext && decoratorContext.type === "prompt") {
                const { path, version } = decoratorContext;
                const template = version === null || version === void 0 ? void 0 : version.template;
                span = span.setAttribute(constants_1.HUMANLOOP_PATH_KEY, path);
                span = span.setAttribute(constants_1.HUMANLOOP_FILE_TYPE_KEY, "prompt");
                if (template !== undefined) {
                    span = span.setAttribute(`${constants_1.HUMANLOOP_FILE_KEY}.template`, 
                    // @ts-ignore
                    template);
                }
            }
            const traceId = (0, context_1.getTraceId)();
            if (traceId) {
                span.setAttribute(`${constants_1.HUMANLOOP_LOG_KEY}.trace_parent_id`, traceId);
            }
        }
    }
    onEnd(span) {
        if ((0, helpers_1.isLLMProviderCall)(span)) {
            const decoratorContext = (0, context_1.getDecoratorContext)();
            if (!decoratorContext || decoratorContext.type !== "prompt") {
                // User made a provider call outside a @prompt context, ignore the span
                return;
            }
            const evaluationContext = (0, context_1.getEvaluationContext)();
            if (evaluationContext && evaluationContext.path === decoratorContext.path) {
                // User made a provider call inside an evaluation context
                // Ignore the span, evaluations.run() will use the output
                // of the decorated function to create the Log
                return;
            }
        }
        if (!span.attributes[constants_1.HUMANLOOP_FILE_TYPE_KEY]) {
            // Not a Humanloop span, unexpected
            console.warn(`Internal error: Span does not have type set:\n${JSON.stringify({
                attributes: span.attributes,
                name: span.name,
                kind: span.kind,
                instrumentationScope: span.instrumentationScope,
            }, null, 2)}`);
            return;
        }
        this.spanExporter.export([span], () => { });
    }
    shutdown() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.spanExporter.shutdown();
        });
    }
    forceFlush() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
}
exports.HumanloopSpanProcessor = HumanloopSpanProcessor;
