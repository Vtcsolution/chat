"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeToOpenTelemetrySpan = writeToOpenTelemetrySpan;
exports.readFromOpenTelemetrySpan = readFromOpenTelemetrySpan;
exports.isLLMProviderCall = isLLMProviderCall;
exports.isHumanloopSpan = isHumanloopSpan;
exports.jsonifyIfNotString = jsonifyIfNotString;
const api_1 = require("@opentelemetry/api");
// Constants for Humanloop attributes
const constants_1 = require("./constants");
/**
 * Transforms a list of values into a dictionary with index values as keys.
 * Nested lists are linearized into dictionaries.
 *
 * @param lst - List of nested values to transform
 * @returns Dictionary representation of the list
 */
function _listToOtelFormat(lst) {
    return lst.reduce((acc, val, idx) => {
        acc[idx.toString()] = Array.isArray(val)
            ? _listToOtelFormat(val)
            : val;
        return acc;
    }, {});
}
/**
 * Writes a Python-like object to the OpenTelemetry Span's attributes.
 * Converts complex objects into a linearized dictionary representation.
 *
 * @param span - OpenTelemetry span to write values to
 * @param value - Object to write to the span attributes
 * @param key - Key prefix for the span attributes
 */
function writeToOpenTelemetrySpan(span, value, key) {
    let toWriteCopy;
    if (Array.isArray(value)) {
        // @ts-ignore
        toWriteCopy = _listToOtelFormat(value);
    }
    else {
        // @ts-ignore
        toWriteCopy = Object.assign({}, value);
    }
    const linearisedAttributes = {};
    const workStack = [
        [key, toWriteCopy],
    ];
    // Remove existing attributes with the same prefix
    Object.keys(span.attributes || {}).forEach((attributeKey) => {
        if (attributeKey.startsWith(key)) {
            delete span.attributes[attributeKey];
        }
    });
    while (workStack.length > 0) {
        const [currentKey, currentValue] = workStack.pop();
        if (currentValue === null) {
            continue;
        }
        if (typeof currentValue === "object" && !Array.isArray(currentValue)) {
            Object.entries(currentValue).forEach(([subKey, subValue]) => {
                workStack.push([
                    currentKey ? `${currentKey}.${subKey}` : subKey,
                    subValue,
                ]);
            });
        }
        else {
            linearisedAttributes[currentKey] = currentValue;
        }
    }
    Object.entries(linearisedAttributes).forEach(([finalKey, finalValue]) => {
        if (finalValue !== null) {
            span.attributes[finalKey] = finalValue;
        }
    });
}
/**
 * Reads a value from the OpenTelemetry span attributes.
 * Reconstructs the original object structure from a key prefix.
 *
 * @param span - OpenTelemetry span to read values from
 * @param key - Key prefix to read from the span attributes
 * @returns Reconstructed object from the span attributes
 */
function readFromOpenTelemetrySpan(span, key = "") {
    if (!span.attributes) {
        throw new Error("Span attributes are empty");
    }
    let result = {};
    const toProcess = [];
    Object.entries(span.attributes).forEach(([spanKey, spanValue]) => {
        if (key === "" || spanKey.startsWith(key)) {
            const newKey = key === "" ? spanKey : spanKey.slice(key.length + 1);
            toProcess.push([newKey, spanValue]);
        }
    });
    if (toProcess.length === 0) {
        if (key === "") {
            return result;
        }
        throw new Error(`Key ${key} not found in span attributes`);
    }
    toProcess.forEach(([spanKey, spanValue]) => {
        const parts = spanKey.split(".");
        let currentLevel = result;
        parts.forEach((part, idx) => {
            if (idx === parts.length - 1) {
                currentLevel[part] = spanValue;
            }
            else {
                if (!(part in currentLevel)) {
                    currentLevel[part] = {};
                }
                currentLevel = currentLevel[part];
            }
        });
    });
    const pseudoToList = (subDict) => {
        if (typeof subDict !== "object" || Array.isArray(subDict)) {
            return subDict;
        }
        Object.keys(subDict).forEach((key) => {
            // @ts-ignore
            subDict[key] = pseudoToList(subDict[key]);
        });
        if (Object.keys(subDict).every((key) => /^\d+$/.test(key))) {
            return Object.values(subDict);
        }
        return subDict;
    };
    result = pseudoToList(result);
    if ("" in result) {
        // User read the root of attributes
        return result[""];
    }
    return result;
}
/**
 * Determines if the span was created by an instrumentor for LLM provider clients.
 *
 * @param span - OpenTelemetry span to check
 * @returns True if the span corresponds to an LLM provider call, false otherwise
 */
function isLLMProviderCall(span) {
    if (!span.instrumentationScope)
        return false;
    const spanInstrumentor = span.instrumentationScope.name;
    const instrumentorPrefixes = [
        "@traceloop/instrumentation-openai",
        "@traceloop/instrumentation-anthropic",
        "@traceloop/instrumentation-cohere",
    ];
    return (span.kind === api_1.SpanKind.CLIENT &&
        instrumentorPrefixes.some((instrumentLibrary) => spanInstrumentor === instrumentLibrary));
}
/**
 * Checks if the span was created by the Humanloop SDK.
 *
 * @param span - OpenTelemetry span to check
 * @returns True if the span was created by the Humanloop SDK, false otherwise
 */
function isHumanloopSpan(span) {
    return span.name.startsWith(constants_1.HUMANLOOP_SPAN_PREFIX);
}
/**
 * Converts the output to JSON if it's not already a string.
 * Throws an error if the output is not JSON serializable.
 *
 * @param func - Function whose output is being converted
 * @param output - Output to be converted
 * @returns JSON string representation of the output
 */
function jsonifyIfNotString(func, output) {
    if (output === undefined || output === null) {
        return undefined;
    }
    if (typeof output !== "string") {
        try {
            return JSON.stringify(output);
        }
        catch (error) {
            throw new TypeError(`Output of ${func.name} must be a string or JSON serializable`);
        }
    }
    return output;
}
