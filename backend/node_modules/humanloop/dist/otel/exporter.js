"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HumanloopSpanExporter = void 0;
const core_1 = require("@opentelemetry/core");
const error_1 = require("../error");
const evals_1 = require("../evals");
const constants_1 = require("./constants");
const helpers_1 = require("./helpers");
class HumanloopSpanExporter {
    constructor(options) {
        this.hlClientHeaders = options.hlClientHeaders;
        this.hlClientBaseUrl = options.hlClientBaseUrl;
        this.shutdownFlag = false;
        this.uploadPromises = [];
    }
    export(spans) {
        if (this.shutdownFlag) {
            console.warn("[HumanloopSpanExporter] Shutting down, not accepting new spans");
            return {
                code: core_1.ExportResultCode.FAILED,
                error: new Error("Exporter is shutting down"),
            };
        }
        for (const span of spans) {
            const fileType = span.attributes[constants_1.HUMANLOOP_FILE_TYPE_KEY];
            if (!fileType) {
                return {
                    code: core_1.ExportResultCode.FAILED,
                    error: new Error(`Internal error: Span does not have type set:\n${JSON.stringify({
                        attributes: span.attributes,
                        name: span.name,
                        kind: span.kind,
                        instrumentationScope: span.instrumentationScope,
                    }, null, 2)}`),
                };
            }
            let logArgs = {};
            let evalCallback = null;
            try {
                logArgs = (0, helpers_1.readFromOpenTelemetrySpan)(span, constants_1.HUMANLOOP_LOG_KEY);
                const path = (0, helpers_1.readFromOpenTelemetrySpan)(span, constants_1.HUMANLOOP_PATH_KEY);
                const evaluationContext = (0, evals_1.getEvaluationContext)();
                if (evaluationContext) {
                    [logArgs, evalCallback] = evaluationContext.logArgsWithContext({
                        logArgs,
                        forOtel: true,
                        path,
                    });
                    (0, helpers_1.writeToOpenTelemetrySpan)(span, logArgs, constants_1.HUMANLOOP_LOG_KEY);
                }
            }
            catch (e) {
                if (!(e instanceof Error)) {
                    evalCallback = null;
                }
            }
            this.uploadPromises.push(this.exportSpan(span, evalCallback));
        }
        return { code: core_1.ExportResultCode.SUCCESS };
    }
    shutdown() {
        return __awaiter(this, void 0, void 0, function* () {
            this.shutdownFlag = true;
            yield Promise.all(this.uploadPromises);
        });
    }
    forceFlush() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.shutdown();
        });
    }
    exportSpan(span, evalContextCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(`${this.hlClientBaseUrl}/import/otel/v1/traces`, {
                method: "POST",
                headers: this.hlClientHeaders,
                body: JSON.stringify(this.spanToPayload(span)),
            });
            if (response.status !== 200) {
                throw new error_1.HumanloopRuntimeError(`Failed to upload OTEL span to Humanloop: ${JSON.stringify(yield response.json())} ${response.status}`);
            }
            if (response.status === 200 && evalContextCallback) {
                const responseBody = yield response.json();
                const logId = responseBody.records[0];
                yield evalContextCallback(logId);
            }
        });
    }
    spanToPayload(span) {
        var _a;
        return {
            resourceSpans: [
                {
                    scopeSpans: [
                        {
                            scope: {
                                name: (0, helpers_1.isLLMProviderCall)(span)
                                    ? "humanloop.sdk.provider"
                                    : "humanloop.sdk.decorator",
                            },
                            spans: [
                                {
                                    traceId: span.spanContext().traceId,
                                    spanId: span.spanContext().spanId,
                                    traceState: ((_a = span.spanContext().traceState) === null || _a === void 0 ? void 0 : _a.serialize()) ||
                                        "",
                                    name: span.name,
                                    kind: span.kind,
                                    startTimeUnixNano: this.hrTimeToNanoseconds(span.startTime),
                                    endTimeUnixNano: this.hrTimeToNanoseconds(span.endTime),
                                    attributes: Object.entries(span.attributes)
                                        .filter(([_, value]) => value !== undefined)
                                        .map(([key, value]) => ({
                                        key,
                                        value: { stringValue: value.toString() },
                                    })),
                                    droppedAttributesCount: span.droppedAttributesCount,
                                    events: [],
                                    links: span.links.map((link) => {
                                        var _a;
                                        return ({
                                            traceId: link.context.traceId,
                                            spanId: link.context.spanId,
                                            traceState: ((_a = link.context.traceState) === null || _a === void 0 ? void 0 : _a.serialize()) || "",
                                            attributes: link.attributes
                                                ? Object.entries(link.attributes)
                                                    .filter(([_, value]) => value !== undefined)
                                                    .map(([key, value]) => ({
                                                    key,
                                                    value: {
                                                        stringValue: value.toString(),
                                                    },
                                                }))
                                                : [],
                                            droppedAttributesCount: link.droppedAttributesCount || 0,
                                        });
                                    }),
                                    droppedEventsCount: span.droppedEventsCount,
                                    droppedLinksCount: span.droppedLinksCount,
                                },
                            ],
                        },
                    ],
                },
            ],
        };
    }
    hrTimeToNanoseconds(hrTime) {
        const [seconds, nanoseconds] = hrTime;
        return seconds * 1e9 + nanoseconds;
    }
}
exports.HumanloopSpanExporter = HumanloopSpanExporter;
